-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_D_FF_AS is
  
  port (
    Q: out std_logic;
    notQ: out std_logic;
    Set: in std_logic;
    D: in std_logic;
    C: in std_logic;
    Clr: in std_logic );
end DIG_D_FF_AS;

architecture Behavioral of DIG_D_FF_AS is
   signal state : std_logic := '0';
begin
    process (Set, Clr, C)
    begin
        if (Set='1') then
            state <= NOT('0');
        elsif (Clr='1') then
            state <= '0';
        elsif rising_edge(C) then
            state <= D;
        end if;
    end process;

    Q <= state;
    notQ <= NOT( state );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_1 is
  port (
    p_out: out std_logic;
    sel: in std_logic;
    
    in_0: in std_logic;
    in_1: in std_logic );
end MUX_GATE_1;

architecture Behavioral of MUX_GATE_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity Reg8i is
  port (
    E: in std_logic;
    D: in std_logic_vector(7 downto 0);
    CLK: in std_logic;
    R: in std_logic;
    INC: in std_logic;
    Q: out std_logic_vector(7 downto 0));
end Reg8i;

architecture Behavioral of Reg8i is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
  signal s11: std_logic;
  signal s12: std_logic;
  signal s13: std_logic;
  signal s14: std_logic;
  signal s15: std_logic;
  signal s16: std_logic;
  signal s17: std_logic;
  signal s18: std_logic;
  signal s19: std_logic;
  signal s20: std_logic;
  signal s21: std_logic;
  signal s22: std_logic;
  signal s23: std_logic;
  signal s24: std_logic;
  signal s25: std_logic;
  signal s26: std_logic;
  signal s27: std_logic;
  signal s28: std_logic;
  signal s29: std_logic;
  signal s30: std_logic;
  signal s31: std_logic;
  signal s32: std_logic;
  signal s33: std_logic;
  signal s34: std_logic;
  signal s35: std_logic;
  signal s36: std_logic;
  signal s37: std_logic;
begin
  s10 <= ((E OR INC) AND CLK);
  s30 <= D(0);
  s31 <= D(1);
  s32 <= D(2);
  s33 <= D(3);
  s34 <= D(4);
  s35 <= D(5);
  s36 <= D(6);
  s37 <= D(7);
  gate0: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s9,
      C => s10,
      Clr => R,
      Q => s1,
      notQ => s11);
  gate1: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s12,
      C => s10,
      Clr => R,
      Q => s0);
  gate2: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s13,
      C => s10,
      Clr => R,
      Q => s3);
  gate3: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s14,
      C => s10,
      Clr => R,
      Q => s6);
  gate4: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s18,
      C => s10,
      Clr => R,
      Q => s15);
  gate5: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s22,
      C => s10,
      Clr => R,
      Q => s19);
  gate6: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s26,
      C => s10,
      Clr => R,
      Q => s23);
  gate7: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s29,
      C => s10,
      Clr => R,
      Q => s27);
  gate8: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s2,
      in_1 => s31,
      p_out => s12);
  gate9: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s11,
      in_1 => s30,
      p_out => s9);
  gate10: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s5,
      in_1 => s32,
      p_out => s13);
  gate11: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s8,
      in_1 => s33,
      p_out => s14);
  gate12: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s17,
      in_1 => s34,
      p_out => s18);
  gate13: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s21,
      in_1 => s35,
      p_out => s22);
  gate14: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s25,
      in_1 => s36,
      p_out => s26);
  gate15: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s28,
      in_1 => s37,
      p_out => s29);
  s2 <= (s0 XOR s1);
  s4 <= (s1 AND s0);
  Q(0) <= s1;
  Q(1) <= s0;
  Q(2) <= s3;
  Q(3) <= s6;
  Q(4) <= s15;
  Q(5) <= s19;
  Q(6) <= s23;
  Q(7) <= s27;
  s5 <= (s3 XOR s4);
  s7 <= (s4 AND s3);
  s8 <= (s6 XOR s7);
  s16 <= (s7 AND s6);
  s17 <= (s15 XOR s16);
  s20 <= (s16 AND s15);
  s21 <= (s19 XOR s20);
  s24 <= (s20 AND s19);
  s25 <= (s23 XOR s24);
  s28 <= (s27 XOR (s24 AND s23));
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_1 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic;
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_1;

architecture Behavioral of MUX_GATE_BUS_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_D_FF_AS_BUS is
  generic ( Bits: integer ); 
  port (
    Q: out std_logic_vector ((Bits-1) downto 0);
    notQ: out std_logic_vector ((Bits-1) downto 0);
    Set: in std_logic;
    D: in std_logic_vector ((Bits-1) downto 0);
    C: in std_logic;
    Clr: in std_logic );
end DIG_D_FF_AS_BUS;

architecture Behavioral of DIG_D_FF_AS_BUS is
   signal state : std_logic_vector ((Bits-1) downto 0) := (others => '0');
begin
    process (Set, Clr, C)
    begin
        if (Set='1') then
            state <= NOT((others => '0'));
        elsif (Clr='1') then
            state <= (others => '0');
        elsif rising_edge(C) then
            state <= D;
        end if;
    end process;

    Q <= state;
    notQ <= NOT( state );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity Reg8 is
  port (
    D: in std_logic_vector(7 downto 0);
    R: in std_logic;
    notCLK: in std_logic;
    SR: in std_logic;
    Q: out std_logic_vector(7 downto 0));
end Reg8;

architecture Behavioral of Reg8 is
  signal s0: std_logic_vector(7 downto 0);
  signal s1: std_logic;
begin
  s1 <= NOT notCLK;
  gate0: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 8)
    port map (
      sel => SR,
      in_0 => D,
      in_1 => "00000000",
      p_out => s0);
  gate1: entity work.DIG_D_FF_AS_BUS
    generic map (
      Bits => 8)
    port map (
      Set => '0',
      D => s0,
      C => s1,
      Clr => R,
      Q => Q);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity Reg10i is
  port (
    E: in std_logic;
    D: in std_logic_vector(9 downto 0);
    CLK: in std_logic;
    R: in std_logic;
    INC: in std_logic;
    Q: out std_logic_vector(9 downto 0));
end Reg10i;

architecture Behavioral of Reg10i is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
  signal s11: std_logic;
  signal s12: std_logic;
  signal s13: std_logic;
  signal s14: std_logic;
  signal s15: std_logic;
  signal s16: std_logic;
  signal s17: std_logic;
  signal s18: std_logic;
  signal s19: std_logic;
  signal s20: std_logic;
  signal s21: std_logic;
  signal s22: std_logic;
  signal s23: std_logic;
  signal s24: std_logic;
  signal s25: std_logic;
  signal s26: std_logic;
  signal s27: std_logic;
  signal s28: std_logic;
  signal s29: std_logic;
  signal s30: std_logic;
  signal s31: std_logic;
  signal s32: std_logic;
  signal s33: std_logic;
  signal s34: std_logic;
  signal s35: std_logic;
  signal s36: std_logic;
  signal s37: std_logic;
  signal s38: std_logic;
  signal s39: std_logic;
  signal s40: std_logic;
  signal s41: std_logic;
  signal s42: std_logic;
  signal s43: std_logic;
  signal s44: std_logic;
  signal s45: std_logic;
  signal s46: std_logic;
  signal s47: std_logic;
begin
  s10 <= ((E OR INC) AND CLK);
  s31 <= D(0);
  s32 <= D(1);
  s33 <= D(2);
  s34 <= D(3);
  s35 <= D(4);
  s36 <= D(5);
  s37 <= D(6);
  s38 <= D(7);
  s39 <= D(8);
  s40 <= D(9);
  gate0: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s9,
      C => s10,
      Clr => R,
      Q => s1,
      notQ => s11);
  gate1: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s12,
      C => s10,
      Clr => R,
      Q => s0);
  gate2: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s13,
      C => s10,
      Clr => R,
      Q => s3);
  gate3: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s14,
      C => s10,
      Clr => R,
      Q => s6);
  gate4: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s18,
      C => s10,
      Clr => R,
      Q => s15);
  gate5: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s22,
      C => s10,
      Clr => R,
      Q => s19);
  gate6: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s26,
      C => s10,
      Clr => R,
      Q => s23);
  gate7: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s30,
      C => s10,
      Clr => R,
      Q => s27);
  gate8: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s2,
      in_1 => s32,
      p_out => s12);
  gate9: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s11,
      in_1 => s31,
      p_out => s9);
  gate10: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s5,
      in_1 => s33,
      p_out => s13);
  gate11: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s8,
      in_1 => s34,
      p_out => s14);
  gate12: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s17,
      in_1 => s35,
      p_out => s18);
  gate13: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s21,
      in_1 => s36,
      p_out => s22);
  gate14: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s25,
      in_1 => s37,
      p_out => s26);
  gate15: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s29,
      in_1 => s38,
      p_out => s30);
  gate16: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s45,
      C => s10,
      Clr => R,
      Q => s41);
  gate17: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s47,
      C => s10,
      Clr => R,
      Q => s42);
  gate18: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s44,
      in_1 => s39,
      p_out => s45);
  gate19: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s46,
      in_1 => s40,
      p_out => s47);
  s2 <= (s0 XOR s1);
  s4 <= (s1 AND s0);
  Q(0) <= s1;
  Q(1) <= s0;
  Q(2) <= s3;
  Q(3) <= s6;
  Q(4) <= s15;
  Q(5) <= s19;
  Q(6) <= s23;
  Q(7) <= s27;
  Q(8) <= s41;
  Q(9) <= s42;
  s5 <= (s3 XOR s4);
  s7 <= (s4 AND s3);
  s8 <= (s6 XOR s7);
  s16 <= (s7 AND s6);
  s17 <= (s15 XOR s16);
  s20 <= (s16 AND s15);
  s21 <= (s19 XOR s20);
  s24 <= (s20 AND s19);
  s25 <= (s23 XOR s24);
  s28 <= (s24 AND s23);
  s29 <= (s27 XOR s28);
  s43 <= (s28 AND s27);
  s44 <= (s41 XOR s43);
  s46 <= (s42 XOR (s43 AND s41));
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity Reg10ir is
  port (
    E: in std_logic;
    D: in std_logic_vector(9 downto 0);
    notCLK: in std_logic;
    R: in std_logic;
    INC: in std_logic;
    Q: out std_logic_vector(9 downto 0));
end Reg10ir;

architecture Behavioral of Reg10ir is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
  signal s11: std_logic;
  signal s12: std_logic;
  signal s13: std_logic;
  signal s14: std_logic;
  signal s15: std_logic;
  signal s16: std_logic;
  signal s17: std_logic;
  signal s18: std_logic;
  signal s19: std_logic;
  signal s20: std_logic;
  signal s21: std_logic;
  signal s22: std_logic;
  signal s23: std_logic;
  signal s24: std_logic;
  signal s25: std_logic;
  signal s26: std_logic;
  signal s27: std_logic;
  signal s28: std_logic;
  signal s29: std_logic;
  signal s30: std_logic;
  signal s31: std_logic;
  signal s32: std_logic;
  signal s33: std_logic;
  signal s34: std_logic;
  signal s35: std_logic;
  signal s36: std_logic;
  signal s37: std_logic;
  signal s38: std_logic;
  signal s39: std_logic;
  signal s40: std_logic;
  signal s41: std_logic;
  signal s42: std_logic;
  signal s43: std_logic;
  signal s44: std_logic;
  signal s45: std_logic;
  signal s46: std_logic;
  signal s47: std_logic;
begin
  s10 <= ((E OR INC) AND NOT notCLK);
  s31 <= D(0);
  s32 <= D(1);
  s33 <= D(2);
  s34 <= D(3);
  s35 <= D(4);
  s36 <= D(5);
  s37 <= D(6);
  s38 <= D(7);
  s39 <= D(8);
  s40 <= D(9);
  gate0: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s9,
      C => s10,
      Clr => R,
      Q => s1,
      notQ => s11);
  gate1: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s12,
      C => s10,
      Clr => R,
      Q => s0);
  gate2: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s13,
      C => s10,
      Clr => R,
      Q => s3);
  gate3: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s14,
      C => s10,
      Clr => R,
      Q => s6);
  gate4: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s18,
      C => s10,
      Clr => R,
      Q => s15);
  gate5: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s22,
      C => s10,
      Clr => R,
      Q => s19);
  gate6: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s26,
      C => s10,
      Clr => R,
      Q => s23);
  gate7: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s30,
      C => s10,
      Clr => R,
      Q => s27);
  gate8: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s2,
      in_1 => s32,
      p_out => s12);
  gate9: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s11,
      in_1 => s31,
      p_out => s9);
  gate10: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s5,
      in_1 => s33,
      p_out => s13);
  gate11: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s8,
      in_1 => s34,
      p_out => s14);
  gate12: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s17,
      in_1 => s35,
      p_out => s18);
  gate13: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s21,
      in_1 => s36,
      p_out => s22);
  gate14: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s25,
      in_1 => s37,
      p_out => s26);
  gate15: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s29,
      in_1 => s38,
      p_out => s30);
  gate16: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s45,
      C => s10,
      Clr => R,
      Q => s41);
  gate17: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s47,
      C => s10,
      Clr => R,
      Q => s42);
  gate18: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s44,
      in_1 => s39,
      p_out => s45);
  gate19: entity work.MUX_GATE_1
    port map (
      sel => E,
      in_0 => s46,
      in_1 => s40,
      p_out => s47);
  s2 <= (s0 XOR s1);
  s4 <= (s1 AND s0);
  Q(0) <= s1;
  Q(1) <= s0;
  Q(2) <= s3;
  Q(3) <= s6;
  Q(4) <= s15;
  Q(5) <= s19;
  Q(6) <= s23;
  Q(7) <= s27;
  Q(8) <= s41;
  Q(9) <= s42;
  s5 <= (s3 XOR s4);
  s7 <= (s4 AND s3);
  s8 <= (s6 XOR s7);
  s16 <= (s7 AND s6);
  s17 <= (s15 XOR s16);
  s20 <= (s16 AND s15);
  s21 <= (s19 XOR s20);
  s24 <= (s20 AND s19);
  s25 <= (s23 XOR s24);
  s28 <= (s24 AND s23);
  s29 <= (s27 XOR s28);
  s43 <= (s28 AND s27);
  s44 <= (s41 XOR s43);
  s46 <= (s42 XOR (s43 AND s41));
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity BasicReg8 is
  port (
    E: in std_logic;
    CLK: in std_logic;
    R: in std_logic;
    D: in std_logic_vector(7 downto 0);
    Q: out std_logic_vector(7 downto 0));
end BasicReg8;

architecture Behavioral of BasicReg8 is
  signal s0: std_logic;
begin
  s0 <= (E AND CLK);
  gate0: entity work.DIG_D_FF_AS_BUS
    generic map (
      Bits => 8)
    port map (
      Set => '0',
      D => D,
      C => s0,
      Clr => R,
      Q => Q);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity BasicReg1 is
  port (
    E: in std_logic;
    CLK: in std_logic;
    R: in std_logic;
    D: in std_logic;
    S: in std_logic;
    Q: out std_logic);
end BasicReg1;

architecture Behavioral of BasicReg1 is
  signal s0: std_logic;
begin
  s0 <= (E AND CLK);
  gate0: entity work.DIG_D_FF_AS
    port map (
      Set => S,
      D => D,
      C => s0,
      Clr => R,
      Q => Q);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DIG_RAMDualPort is
  generic (
    Bits : integer;       
    AddrBits : integer ); 
  port (
    D: out std_logic_vector ((Bits-1) downto 0);
    A: in std_logic_vector ((AddrBits-1) downto 0);
    Din: in std_logic_vector ((Bits-1) downto 0);
    str: in std_logic;
    C: in std_logic;
    ld: in std_logic );
end DIG_RAMDualPort;

architecture Behavioral of DIG_RAMDualPort is
    -- CAUTION: uses distributed RAM
    type memoryType is array(0 to (2**AddrBits)-1) of STD_LOGIC_VECTOR((Bits-1) downto 0);
    signal memory : memoryType;
begin
  process ( C )
  begin
    if rising_edge(C) AND (str='1') then
      memory(to_integer(unsigned(A))) <= Din;
    end if;
  end process;
  D <= memory(to_integer(unsigned(A))) when ld='1' else (others => 'Z');
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_Ctrl is
  port (
    D: out std_logic_vector (27 downto 0);
    A: in std_logic_vector (5 downto 0);
    sel: in std_logic );
end DIG_ROM_Ctrl;

architecture Behavioral of DIG_ROM_Ctrl is
  type mem is array ( 0 to 13) of std_logic_vector (27 downto 0);
  constant my_Rom : mem := (
    "0000000000000000000000000000", "0000000000000000000000010111", 
    "0000000000000000000100000101", "0000000000000000010000000101", 
    "0000000000000000000100001000", "0000000000000000001000010010", 
    "0000000000000000010000001000", "0000000000000000010000010010", 
    "0000000000000000100000001000", "0000000000000000101000000000", 
    "0000000000010000100000001100", "0000000000010000101000000100", 
    "0000000000000010000000000100", "0000000000000100000000000100"
    );
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= (others => 'Z');
    elsif A > "001101" then
      D <= (others => '0');
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_PROM is
  port (
    D: out std_logic_vector (7 downto 0);
    A: in std_logic_vector (9 downto 0);
    sel: in std_logic );
end DIG_ROM_PROM;

architecture Behavioral of DIG_ROM_PROM is
  type mem is array ( 0 to 14) of std_logic_vector (7 downto 0);
  constant my_Rom : mem := (
    "00000000", "01000011", "00001001", "00000000", "00000000", "00000000", 
    "00000000", "00000000", "00000000", "00001010", "00001100", "00000010", 
    "00000010", "00001011", "00010001");
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= (others => 'Z');
    elsif A > "0000001110" then
      D <= (others => '0');
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Add is
  generic ( Bits: integer ); 
  port (
    s: out std_logic_vector((Bits-1) downto 0);
    c_o: out std_logic;
    a: in std_logic_vector((Bits-1) downto 0);
    b: in std_logic_vector((Bits-1) downto 0);
    c_i: in std_logic );
end DIG_Add;

architecture Behavioral of DIG_Add is
   signal temp : std_logic_vector(Bits downto 0);
begin
   temp <= ('0' & a) + b + c_i;

   s    <= temp((Bits-1) downto 0);
   c_o  <= temp(Bits);
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Sub is
  generic ( Bits: integer ); 
  port (
    s: out std_logic_vector((Bits-1) downto 0);
    c_o: out std_logic;
    a: in std_logic_vector((Bits-1) downto 0);
    b: in std_logic_vector((Bits-1) downto 0);
    c_i: in std_logic );
end DIG_Sub;

architecture Behavioral of DIG_Sub is
   signal temp : std_logic_vector(Bits downto 0);
begin
   temp <= ('0' & a) - b - c_i;

   s    <= temp((Bits-1) downto 0);
   c_o  <= temp(Bits);
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity LSL8 is
  port (
    Di: in std_logic_vector(7 downto 0); -- data input
    Ci: in std_logic; -- carry input
    Do: out std_logic_vector(7 downto 0); -- data output
    Co: out std_logic -- carry output
    );
end LSL8;

architecture Behavioral of LSL8 is
begin
  Do(0) <= Ci;
  Do(7 downto 1) <= Di(6 downto 0);
  Co <= Di(7);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Shift right. So a division by two.
-- The carry bit is inserted at the top. And the least 
-- significant bit is output as a new carry bit.
entity LSR8 is
  port (
    Di: in std_logic_vector(7 downto 0); -- data input
    Ci: in std_logic; -- carry input
    Do: out std_logic_vector(7 downto 0); -- data output
    Co: out std_logic -- carry output
    );
end LSR8;

architecture Behavioral of LSR8 is
begin
  Do(6 downto 0) <= Di(7 downto 1);
  Do(7) <= Ci;
  Co <= Di(0);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
entity COMP_GATE_SIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_SIGNED;

architecture Behavioral of COMP_GATE_SIGNED is
begin
  process(a, b)
  begin
    if (signed(a) > signed(b)) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (signed(a) < signed(b)) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_4 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (3 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0);
    in_4: in std_logic_vector ((Bits-1) downto 0);
    in_5: in std_logic_vector ((Bits-1) downto 0);
    in_6: in std_logic_vector ((Bits-1) downto 0);
    in_7: in std_logic_vector ((Bits-1) downto 0);
    in_8: in std_logic_vector ((Bits-1) downto 0);
    in_9: in std_logic_vector ((Bits-1) downto 0);
    in_10: in std_logic_vector ((Bits-1) downto 0);
    in_11: in std_logic_vector ((Bits-1) downto 0);
    in_12: in std_logic_vector ((Bits-1) downto 0);
    in_13: in std_logic_vector ((Bits-1) downto 0);
    in_14: in std_logic_vector ((Bits-1) downto 0);
    in_15: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_4;

architecture Behavioral of MUX_GATE_BUS_4 is
begin
  with sel select
    p_out <=
      in_0 when "0000",
      in_1 when "0001",
      in_2 when "0010",
      in_3 when "0011",
      in_4 when "0100",
      in_5 when "0101",
      in_6 when "0110",
      in_7 when "0111",
      in_8 when "1000",
      in_9 when "1001",
      in_10 when "1010",
      in_11 when "1011",
      in_12 when "1100",
      in_13 when "1101",
      in_14 when "1110",
      in_15 when "1111",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_4 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (3 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic;
    in_4: in std_logic;
    in_5: in std_logic;
    in_6: in std_logic;
    in_7: in std_logic;
    in_8: in std_logic;
    in_9: in std_logic;
    in_10: in std_logic;
    in_11: in std_logic;
    in_12: in std_logic;
    in_13: in std_logic;
    in_14: in std_logic;
    in_15: in std_logic );
end MUX_GATE_4;

architecture Behavioral of MUX_GATE_4 is
begin
  with sel select
    p_out <=
      in_0 when "0000",
      in_1 when "0001",
      in_2 when "0010",
      in_3 when "0011",
      in_4 when "0100",
      in_5 when "0101",
      in_6 when "0110",
      in_7 when "0111",
      in_8 when "1000",
      in_9 when "1001",
      in_10 when "1010",
      in_11 when "1011",
      in_12 when "1100",
      in_13 when "1101",
      in_14 when "1110",
      in_15 when "1111",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity ALU8Bits is
  port (
    A: in std_logic_vector(7 downto 0);
    B: in std_logic_vector(7 downto 0);
    Cin: in std_logic;
    OP: in std_logic_vector(3 downto 0);
    Y: out std_logic_vector(7 downto 0);
    ST: out std_logic_vector(7 downto 0));
end ALU8Bits;

architecture Behavioral of ALU8Bits is
  signal s0: std_logic_vector(7 downto 0);
  signal s1: std_logic_vector(7 downto 0);
  signal s2: std_logic_vector(7 downto 0);
  signal s3: std_logic_vector(7 downto 0);
  signal s4: std_logic_vector(7 downto 0);
  signal s5: std_logic_vector(7 downto 0);
  signal s6: std_logic_vector(7 downto 0);
  signal s7: std_logic_vector(7 downto 0);
  signal s8: std_logic_vector(7 downto 0);
  signal s9: std_logic_vector(7 downto 0);
  signal s10: std_logic;
  signal s11: std_logic;
  signal s12: std_logic;
  signal s13: std_logic;
  signal s14: std_logic;
  signal s15: std_logic;
  signal C: std_logic;
  signal G: std_logic;
  signal E: std_logic;
  signal S: std_logic;
  signal Z: std_logic;
begin
  s0 <= NOT A;
  s2 <= (A AND B);
  s1 <= (A OR B);
  s3 <= (A XOR B);
  gate0: entity work.DIG_Add
    generic map (
      Bits => 8)
    port map (
      a => A,
      b => B,
      c_i => Cin,
      s => s4,
      c_o => s10);
  gate1: entity work.DIG_Sub
    generic map (
      Bits => 8)
    port map (
      a => A,
      b => B,
      c_i => Cin,
      s => s5,
      c_o => s11);
  gate2: entity work.DIG_Sub
    generic map (
      Bits => 8)
    port map (
      a => B,
      b => "00000001",
      c_i => '0',
      s => s7,
      c_o => s13);
  gate3: entity work.LSL8
    port map (
      Di => A,
      Ci => Cin,
      Do => s8,
      Co => s14);
  gate4: entity work.LSR8
    port map (
      Di => A,
      Ci => Cin,
      Do => s9,
      Co => s15);
  gate5: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 8)
    port map (
      a => A,
      b => B,
      gr => G,
      eq => E,
      le => S);
  gate6: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 8)
    port map (
      a => A,
      b => "00000000",
      eq => Z);
  gate7: entity work.DIG_Sub
    generic map (
      Bits => 8)
    port map (
      a => A,
      b => "00000001",
      c_i => '0',
      s => s6,
      c_o => s12);
  gate8: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 8)
    port map (
      sel => OP,
      in_0 => A,
      in_1 => B,
      in_2 => s0,
      in_3 => s1,
      in_4 => s2,
      in_5 => s3,
      in_6 => s4,
      in_7 => s5,
      in_8 => s6,
      in_9 => s7,
      in_10 => s8,
      in_11 => s9,
      in_12 => "00000000",
      in_13 => "00000000",
      in_14 => "00000000",
      in_15 => "00000000",
      p_out => Y);
  gate9: entity work.MUX_GATE_4
    port map (
      sel => OP,
      in_0 => '0',
      in_1 => '0',
      in_2 => '0',
      in_3 => '0',
      in_4 => '0',
      in_5 => '0',
      in_6 => s10,
      in_7 => s11,
      in_8 => s12,
      in_9 => s13,
      in_10 => s14,
      in_11 => s15,
      in_12 => '0',
      in_13 => '0',
      in_14 => '0',
      in_15 => '0',
      p_out => C);
  ST(0) <= Z;
  ST(1) <= E;
  ST(2) <= G;
  ST(3) <= S;
  ST(4) <= A(7);
  ST(5) <= C;
  ST(6) <= '0';
  ST(7) <= '0';
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DRIVER_INV_GATE_BUS is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    p_in: in std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic );
end DRIVER_INV_GATE_BUS;

architecture Behavioral of DRIVER_INV_GATE_BUS is
begin
  p_out <= p_in when sel = '1' else (others => 'Z');
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity Demux8 is
  port (
    I: in std_logic_vector(7 downto 0);
    S: in std_logic;
    O0: out std_logic_vector(7 downto 0);
    O1: out std_logic_vector(7 downto 0));
end Demux8;

architecture Behavioral of Demux8 is
  signal s0: std_logic;
begin
  gate0: entity work.DRIVER_INV_GATE_BUS
    generic map (
      Bits => 8)
    port map (
      p_in => I,
      sel => S,
      p_out => O1);
  s0 <= NOT S;
  gate1: entity work.DRIVER_INV_GATE_BUS
    generic map (
      Bits => 8)
    port map (
      p_in => I,
      sel => s0,
      p_out => O0);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_3 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (2 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic;
    in_4: in std_logic;
    in_5: in std_logic;
    in_6: in std_logic;
    in_7: in std_logic );
end MUX_GATE_3;

architecture Behavioral of MUX_GATE_3 is
begin
  with sel select
    p_out <=
      in_0 when "000",
      in_1 when "001",
      in_2 when "010",
      in_3 when "011",
      in_4 when "100",
      in_5 when "101",
      in_6 when "110",
      in_7 when "111",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_2 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (1 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_2;

architecture Behavioral of MUX_GATE_BUS_2 is
begin
  with sel select
    p_out <=
      in_0 when "00",
      in_1 when "01",
      in_2 when "10",
      in_3 when "11",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    Clock: in std_logic;
    Reset: in std_logic;
    p_IN: in std_logic_vector(7 downto 0);
    p_OUT: out std_logic_vector(7 downto 0));
end main;

architecture Behavioral of main is
  signal AE: std_logic;
  signal s0: std_logic_vector(7 downto 0);
  signal AINC: std_logic;
  signal A: std_logic_vector(7 downto 0);
  signal s1: std_logic_vector(7 downto 0);
  signal s2: std_logic_vector(7 downto 0);
  signal s3: std_logic_vector(7 downto 0);
  signal s4: std_logic;
  signal s5: std_logic_vector(3 downto 0);
  signal BE: std_logic;
  signal p_BUS: std_logic_vector(7 downto 0);
  signal BINC: std_logic;
  signal B: std_logic_vector(7 downto 0);
  signal MUX: std_logic;
  signal s6: std_logic_vector(7 downto 0);
  signal Z: std_logic;
  signal E: std_logic;
  signal G: std_logic;
  signal S: std_logic;
  signal N: std_logic;
  signal C: std_logic;
  signal s7: std_logic_vector(2 downto 0);
  signal s8: std_logic;
  signal RAMAMUX: std_logic;
  signal AR: std_logic_vector(9 downto 0);
  signal s9: std_logic_vector(9 downto 0);
  signal s10: std_logic_vector(9 downto 0);
  signal s11: std_logic_vector(9 downto 0);
  signal PROM: std_logic_vector(7 downto 0);
  signal PROMAMUX: std_logic;
  signal PC: std_logic_vector(9 downto 0);
  signal s12: std_logic_vector(5 downto 0);
  signal s13: std_logic_vector(27 downto 0);
  signal IR: std_logic_vector(7 downto 0);
  signal A89: std_logic_vector(1 downto 0);
  signal IRZ: std_logic;
  signal AluBMux: std_logic;
  signal ARE: std_logic;
  signal RAME: std_logic;
  signal RAMOE: std_logic;
  signal ARINC: std_logic;
  signal OUTE: std_logic;
  signal INE: std_logic;
  signal CSET: std_logic;
  signal CE: std_logic;
  signal XXX: std_logic;
  signal s14: std_logic_vector(9 downto 0);
  signal s15: std_logic_vector(7 downto 0);
  signal s16: std_logic;
  signal s17: std_logic_vector(1 downto 0);
  signal s18: std_logic_vector(7 downto 0);
begin
  gate0: entity work.Reg8i -- A
    port map (
      E => AE,
      D => s0,
      CLK => Clock,
      R => Reset,
      INC => AINC,
      Q => A);
  gate1: entity work.Reg8i -- B
    port map (
      E => BE,
      D => p_BUS,
      CLK => Clock,
      R => Reset,
      INC => BINC,
      Q => B);
  gate2: entity work.Reg8 -- IR
    port map (
      D => PROM,
      R => Reset,
      notCLK => Clock,
      SR => IRZ,
      Q => IR);
  gate3: entity work.Reg10i -- AR
    port map (
      E => ARE,
      D => s14,
      CLK => Clock,
      R => Reset,
      INC => ARINC,
      Q => AR);
  gate4: entity work.Reg10ir -- PC
    port map (
      E => s8,
      D => s9,
      notCLK => Clock,
      R => Reset,
      INC => '1',
      Q => PC);
  gate5: entity work.BasicReg8 -- Out
    port map (
      E => OUTE,
      CLK => Clock,
      R => Reset,
      D => p_BUS,
      Q => p_OUT);
  gate6: entity work.BasicReg8 -- In
    port map (
      E => INE,
      CLK => Clock,
      R => Reset,
      D => p_IN,
      Q => s15);
  gate7: entity work.BasicReg1 -- CARRY
    port map (
      E => CE,
      CLK => Clock,
      R => s16,
      D => C,
      S => CSET,
      Q => s4);
  s16 <= (s13(25) OR Reset);
  gate8: entity work.DIG_RAMDualPort
    generic map (
      Bits => 8,
      AddrBits => 10)
    port map (
      A => s10,
      Din => p_BUS,
      str => RAME,
      C => Clock,
      ld => RAMOE,
      D => s18);
  s12 <= IR(5 downto 0);
  A89 <= IR(7 downto 6);
  gate9: entity work.DIG_ROM_Ctrl -- Ctrl
    port map (
      A => s12,
      sel => '1',
      D => s13);
  s5(0) <= s13(4);
  s5(1) <= s13(5);
  s5(2) <= s13(6);
  s5(3) <= s13(7);
  s7(0) <= s13(13);
  s7(1) <= s13(14);
  s7(2) <= s13(15);
  s17(0) <= s13(0);
  s17(1) <= s13(21);
  AE <= s13(1);
  IRZ <= s13(2);
  MUX <= s13(3);
  BE <= s13(8);
  AluBMux <= s13(9);
  ARE <= s13(10);
  RAME <= s13(11);
  RAMOE <= s13(12);
  RAMAMUX <= s13(16);
  PROMAMUX <= s13(17);
  AINC <= s13(18);
  BINC <= s13(19);
  ARINC <= s13(20);
  OUTE <= s13(22);
  INE <= s13(23);
  CSET <= s13(24);
  CE <= s13(26);
  XXX <= s13(27);
  gate10: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 10)
    port map (
      sel => PROMAMUX,
      in_0 => PC,
      in_1 => AR,
      p_out => s11);
  gate11: entity work.DIG_ROM_PROM -- PROM
    port map (
      A => s11,
      sel => '1',
      D => PROM);
  s9(7 downto 0) <= PROM;
  s9(9 downto 8) <= A89;
  gate12: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 10)
    port map (
      sel => RAMAMUX,
      in_0 => AR,
      in_1 => s9,
      p_out => s10);
  gate13: entity work.ALU8Bits
    port map (
      A => A,
      B => s3,
      Cin => s4,
      OP => s5,
      Y => s1,
      ST => s2);
  gate14: entity work.Demux8 -- Demux
    port map (
      I => s1,
      S => MUX,
      O0 => s0,
      O1 => s6);
  gate15: entity work.MUX_GATE_3
    port map (
      sel => s7,
      in_0 => '0',
      in_1 => '1',
      in_2 => Z,
      in_3 => E,
      in_4 => G,
      in_5 => S,
      in_6 => N,
      in_7 => C,
      p_out => s8);
  s14(7 downto 0) <= p_BUS;
  s14(9 downto 8) <= A89;
  gate16: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 8)
    port map (
      sel => AluBMux,
      in_0 => p_BUS,
      in_1 => B,
      p_out => s3);
  gate17: entity work.MUX_GATE_BUS_2
    generic map (
      Bits => 8)
    port map (
      sel => s17,
      in_0 => s6,
      in_1 => s18,
      in_2 => s15,
      in_3 => PROM,
      p_out => p_BUS);
  Z <= s2(0);
  E <= s2(1);
  G <= s2(2);
  S <= s2(3);
  N <= s2(4);
  C <= s2(5);
end Behavioral;
